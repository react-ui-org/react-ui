// 1. Due to complexity, it's easier and safer to resolve variant custom properties dynamically with
//    a mixin. This way it's also easier to make theming adjustments to all supported modifications
//    in one place. Generated custom properties are consumed mainly in foundation field styles (see
//    `tools/forms/_foundation.scss` for more).
//
// 2. Interaction states other than `default` default to the `default` (sic!) state appearance if
//    corresponding custom properties are not provided.
//
// 3. `.input:focus` is added just in case `:focus-within` doesn't work.

@use 'sass:list';
@use '../../settings/forms' as settings;
@use '../../theme/forms' as theme;

@mixin _disabled-state() {
  opacity: theme.$field-disabled-opacity;
  cursor: theme.$field-disabled-cursor;
}

// 1.
@mixin _get-themeable-properties($variant, $state) {
  @if (not list.index(map-keys(settings.$themeable-variant-states), $variant)) {
    @error "Invalid variant specified! #{$variant} doesn't exist. "
      + "Choose one of #{map-keys(settings.$themeable-variant-states)}.";
  }

  @if (not list.index(map-keys(settings.$themeable-state-properties), $state)) {
    @error "Invalid state specified! #{$state} doesn't exist. "
      + "Choose one of #{map-keys(settings.$themeable-state-properties)}.";
  }

  $properties: map-get(settings.$themeable-state-properties, $state);

  @if ($state == default) {
    @each $property in $properties {
      --rui-local-#{$property}: var(--rui-form-field-#{$variant}-#{$state}-#{$property});
    }
  }

  // 2.
  @else {
    @each $property in $properties {
      --rui-local-#{$property}:
        var(
          --rui-form-field-#{$variant}-#{$state}-#{$property},
          var(--rui-form-field-#{$variant}-default-#{$property})
        );
    }
  }
}

@mixin _get-variant-theme($variant) {
  $themeable-states: map-get(settings.$themeable-variant-states, $variant);

  @if (list.index($themeable-states, hover)) {
    @include _get-themeable-properties($variant, default);

    &:hover {
      @include _get-themeable-properties($variant, hover);
    }
  }

  @else {
    &,
    &:hover {
      @include _get-themeable-properties($variant, default);
    }
  }

  @if (list.index($themeable-states, focus)) {
    // 3.
    &:focus-within,
    &:focus-within:hover,
    .input:focus {
      @include _get-themeable-properties($variant, focus);
    }
  }

  @if (list.index($themeable-states, disabled)) {
    &.isRootDisabled {
      @include _get-themeable-properties($variant, disabled);
    }
  }
}

@mixin field-variant($variant, $has-caret: false) {
  @include _get-variant-theme($variant);

  @if ($variant == 'filled' or $variant == 'outline') {
    .input:disabled {
      @include _disabled-state();
    }
  }

  @if ($variant == 'filled') {
    .input {
      border-top-color: transparent;
      border-right-color: transparent;
      border-left-color: transparent;
      border-bottom-right-radius: 0;
      border-bottom-left-radius: 0;
    }
  }

  @if ($variant == 'outline' and $has-caret) {
    .caret {
      border-left: theme.$field-border-width theme.$field-caret-border-style var(--rui-local-border-color);
      background-color: theme.$field-caret-background;
    }

    &.isRootDisabled .caret {
      @include _disabled-state();
    }
  }
}
